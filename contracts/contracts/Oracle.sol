// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

interface IUltraVerifier {
    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool);
}

/**
 * @title Oracle
 * @notice Contract for verifying TLSNotary proofs using a Noir circuit verifier
 * @dev This contract acts as a wrapper around the UltraHonk verifier generated from Noir
 */
contract Oracle {
    /// @notice Address of the UltraHonk verifier contract
    IUltraVerifier public immutable verifier;

    /// @notice Struct to store verified attestation data
    struct VerifiedAttestation {
        bytes32 notaryPubKeyX;
        bytes32 notaryPubKeyY;
        bytes32 headerHash;
        uint256 price;
        uint256 timestamp;
        address submitter;
        bool exists;
    }

    /// @notice Mapping of header hash to verified attestation data
    mapping(bytes32 => VerifiedAttestation) public verifiedAttestations;

    /// @notice Emitted when a TLSNotary proof is successfully verified
    event ProofVerified(
        bytes32 indexed headerHash,
        bytes32 indexed notaryPubKeyX,
        bytes32 indexed notaryPubKeyY,
        uint256 price,
        address submitter,
        uint256 timestamp
    );

    /// @notice Emitted when a verification attempt fails
    event VerificationFailed(
        address indexed submitter,
        string reason
    );

    error InvalidProof();
    error InvalidPublicInputs();
    error AttestationAlreadyExists();

    /**
     * @notice Constructs a new TLSNotaryVerifier
     * @param _verifier Address of the deployed UltraHonk verifier contract
     */
    constructor(address _verifier) {
        verifier = IUltraVerifier(_verifier);
    }

    /**
     * @notice Verifies a TLSNotary proof with price data
     * @dev The proof format follows UltraHonk proving system requirements
     * @param proof The ZK proof bytes generated by the Noir circuit
     * @param publicInputs Array of public inputs:
     *        - [0]: notaryPubKeyX
     *        - [1]: notaryPubKeyY
     *        - [2-...]: serializedHeader (54 bytes packed into bytes32 array)
     * @param price The price value extracted from the verified attestation
     * @return verified True if the proof is valid
     */
    function verifyProof(
        bytes calldata proof,
        bytes32[] calldata publicInputs,
        uint256 price
    ) external returns (bool verified) {

        // Extract notary public key from public inputs
        bytes32 notaryPubKeyX = publicInputs[0];
        bytes32 notaryPubKeyY = publicInputs[1];

        // Call the UltraHonk verifier
        bool result = verifier.verify(proof, publicInputs);

        if (!result) {
            emit VerificationFailed(msg.sender, "Proof verification failed");
            revert InvalidProof();
        }

        // Create a unique identifier for this attestation
        // Since we don't have the header in public inputs, use the proof + pubkeys
        bytes32 attestationId = keccak256(abi.encodePacked(notaryPubKeyX, notaryPubKeyY, proof));

        // Prevent duplicate attestations
        if (verifiedAttestations[attestationId].exists) {
            revert AttestationAlreadyExists();
        }

        // Store the verified attestation
        verifiedAttestations[attestationId] = VerifiedAttestation({
            notaryPubKeyX: notaryPubKeyX,
            notaryPubKeyY: notaryPubKeyY,
            headerHash: attestationId,
            price: price,
            timestamp: block.timestamp,
            submitter: msg.sender,
            exists: true
        });

        emit ProofVerified(
            attestationId,
            notaryPubKeyX,
            notaryPubKeyY,
            price,
            msg.sender,
            block.timestamp
        );

        return true;
    }

    /**
     * @notice View function to check if a proof is valid without state changes
     * @param proof The ZK proof bytes
     * @param publicInputs Array of public inputs
     * @return verified True if the proof is valid
     */
    function verifyProofView(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external view returns (bool verified) {
        if (publicInputs.length < 3) {
            return false;
        }

        return verifier.verify(proof, publicInputs);
    }

    /**
     * @notice Get the verified attestation data by header hash
     * @param headerHash The hash of the header
     * @return attestation The verified attestation data
     */
    function getAttestation(bytes32 headerHash)
        external
        view
        returns (VerifiedAttestation memory attestation)
    {
        return verifiedAttestations[headerHash];
    }

    /**
     * @notice Get the price from a verified attestation
     * @param headerHash The hash of the header
     * @return price The price value
     */
    function getPrice(bytes32 headerHash) external view returns (uint256 price) {
        require(verifiedAttestations[headerHash].exists, "Attestation does not exist");
        return verifiedAttestations[headerHash].price;
    }

    /**
     * @notice Check if an attestation exists
     * @param headerHash The hash of the header
     * @return exists True if the attestation exists
     */
    function attestationExists(bytes32 headerHash) external view returns (bool exists) {
        return verifiedAttestations[headerHash].exists;
    }

    /**
     * @notice Get the notary public key used for a specific attestation
     * @param headerHash The hash of the header
     * @return pubKeyX X coordinate
     * @return pubKeyY Y coordinate
     */
    function getAttestationNotaryKey(bytes32 headerHash)
        external
        view
        returns (bytes32 pubKeyX, bytes32 pubKeyY)
    {
        require(verifiedAttestations[headerHash].exists, "Attestation does not exist");
        return (
            verifiedAttestations[headerHash].notaryPubKeyX,
            verifiedAttestations[headerHash].notaryPubKeyY
        );
    }
}
