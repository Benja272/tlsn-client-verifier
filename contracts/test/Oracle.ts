import assert from "node:assert/strict";
import { describe, it } from "node:test";
import { readFile } from "node:fs/promises";
import { join } from "node:path";

import { network } from "hardhat";
import { parseEther, toHex, bytesToHex } from "viem";

describe("Oracle", async function () {
  const { viem } = await network.connect();
  const publicClient = await viem.getPublicClient();

  it("Should deploy Oracle contract with verifier address", async function () {
    // Deploy the Verifier contract
    const verifier = await viem.deployContract("HonkVerifier");

    // Deploy the Oracle contract
    const oracle = await viem.deployContract("Oracle", [verifier.address]);

    // Verify the verifier address is set correctly
    const verifierAddress = await oracle.read.verifier() as `0x${string}`;
    assert.equal(verifierAddress.toLowerCase(), verifier.address.toLowerCase());
  });

  it("Should verify real proof from TLSNotary", async function () {
    // Load real proof data generated by npm start
    let proofData: any;
    try {
      const proofDataPath = join(process.cwd(), "test", "fixtures", "proof_data.json");
      const proofDataContent = await readFile(proofDataPath, "utf-8");
      proofData = JSON.parse(proofDataContent);
    } catch (error) {
      console.log("‚ö†Ô∏è  No proof data found. Run 'npm start' in the root directory to generate proof_data.json");
      console.log("   Skipping this test...");
      return; // Skip test if no proof data available
    }

    // Deploy contracts
    const verifier = await viem.deployContract("HonkVerifier");
    const oracle = await viem.deployContract("Oracle", [verifier.address]);

    // Convert proof data to the format expected by Solidity
    const proofBytes = bytesToHex(new Uint8Array(proofData.proof));

    // Use the public inputs directly from the saved proof data
    // They are already formatted as bytes32 hex strings
    const publicInputs = proofData.publicInputs as `0x${string}`[];

    console.log("Public inputs count:", publicInputs.length);
    console.log("Expected: 64 (32 for pub_key_x + 32 for pub_key_y)");

    // Parse price (assuming it's a string like "1.23")
    const priceValue = parseEther(proofData.price);

    console.log("üìù Proof bytes length:", proofData.proof.length);
    console.log("üìù Public inputs:", publicInputs.length);
    console.log("üìù Price:", proofData.price);

    // Verify the proof
    try {
      const tx = await oracle.write.verifyProof([proofBytes, publicInputs, priceValue]);
      const receipt = await publicClient.waitForTransactionReceipt({ hash: tx });

      // Check that the transaction succeeded
      assert.equal(receipt.status, "success");

      console.log("‚úÖ Proof verified successfully!");
    } catch (error: any) {
      console.error("‚ùå Proof verification failed:");
      console.error("Error:", error.message);
      console.error("Cause:", error.cause?.message);
      throw error;
    }
  });

  it("Should store and retrieve verified attestation with price", async function () {
    // Deploy contracts
    const verifier = await viem.deployContract("HonkVerifier");
    const oracle = await viem.deployContract("Oracle", [verifier.address]);

    // Test with mock data (since we can't verify without real proof)
    // This just tests the storage/retrieval logic structure
    const randomHash = toHex(new Uint8Array(32).fill(99), { size: 32 });

    // Check non-existent attestation
    const exists = await oracle.read.attestationExists([randomHash]);
    assert.equal(exists, false);

    // After a real proof verification, you would be able to:
    // const attestation = await oracle.read.getAttestation([headerHash]);
    // assert.equal(attestation.price, expectedPrice);
  });

  it("Should check if attestation exists", async function () {
    const verifier = await viem.deployContract("HonkVerifier");
    const oracle = await viem.deployContract("Oracle", [verifier.address]);

    // Test non-existent attestation
    const randomHash = toHex(new Uint8Array(32).fill(99), { size: 32 });
    const exists = await oracle.read.attestationExists([randomHash]);
    assert.equal(exists, false);
  });
});
